#include "ws2812b.h"
#include <stdio.h>
#include "hardware/clocks.h"
#include "hardware/pio.h"
#include "math.h"
#include "pico/stdlib.h"

// .h file generated by CMake
#include "ws2812b.pio.h"

// Puts the next pixel in the WS2812B matrix
static inline void put_pixel(PIO pio, uint sm, uint32_t pixel_grb) {
    pio_sm_put_blocking(pio, sm, pixel_grb);
}

// Helper function to convert three separate rgb values into a single 32-bit
// value in the GRB format expected by the WS2812B
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return ((uint32_t)(r) << 16u) | ((uint32_t)(g) << 24u) |
           ((uint32_t)(b) << 8u);
}

// Helper function to set the target color of the breathing animation
void breathingAnimationSetTarget(breathing_animation_state_t* state,
                                 uint8_t r,
                                 uint8_t g,
                                 uint8_t b) {
    state->r = r;
    state->g = g;
    state->b = b;
}

void playBreathingAnimation(breathing_animation_state_t* state) {
    if (!time_reached(state->next_update)) {
        return;
    }

    // Smooth breathing formula, based on:
    // https://thingpulse.com/breathing-leds-cracking-the-algorithm-behind-our-breathing-pattern/
    // Tuned for the leds on the BitDogLab board:
    // Will output values between ~26 and 80
    uint32_t millis = to_ms_since_boot(get_absolute_time());
    uint8_t brightness = (exp(sin(millis / 2000.0 * M_PI)) + 0.815) * 22.639;

    // Scale the brightness of each color channel while keeping the same ratio between them
    state->r_current = (uint8_t)(brightness * (state->r / 255.0f));
    state->g_current = (uint8_t)(brightness * (state->g / 255.0f));
    state->b_current = (uint8_t)(brightness * (state->b / 255.0f));

    // Update all LEDs using scaled color values
    for (int i = 0; i < WS2812B_LED_COUNT; i++) {
        put_pixel(
            state->pio, state->sm,
            urgb_u32(state->r_current, state->g_current, state->b_current));
    }
    printf("Brightness: %d\n", brightness);
    printf("RGB(%d, %d, %d)\n", state->r_current, state->g_current,
           state->b_current);

    // Schedule next update
    state->next_update = make_timeout_time_ms(state->update_interval_ms);
}

breathing_animation_state_t initBreathingAnimation() {
    breathing_animation_state_t anim;

    // Initial animation state
    anim = (breathing_animation_state_t){.r = 0,
                                         .g = 0,
                                         .b = 0,
                                         .r_current = 0,
                                         .g_current = 0,
                                         .b_current = 0,
                                         .next_update = get_absolute_time(),
                                         .update_interval_ms = 20};

    // Claim and setup a pio machine
    uint offset;
    bool success = pio_claim_free_sm_and_add_program_for_gpio_range(
        &ws2812b_program, &anim.pio, &anim.sm, &offset, WS2812B_PIN, 1, true);
    hard_assert(success);
    ws2812b_program_init(anim.pio, anim.sm, offset, WS2812B_PIN, 800000);

    return anim;
}
